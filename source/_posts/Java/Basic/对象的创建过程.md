---
title: 对象的创建过程
summary: 对象的创建过程
categories: java
date: 2018-09-07 09:25:00
tags:
- java
---
## 对象的创建过程
### 对象的编译

Java 基础
``` java
    // source code
    class T {
        int m = 8;
    }

    T t = new T();

    // after compile
    0 new #2 <T>     // 申请内存  赋默认值 m = 0
    3 dup
    4 invokespecial #3 <T.<init>>   // 特殊调用  默认构造方法  m = 8
    7 astore_1      // 建立关联   t 指向 此对象
    8 return
```
### 对象创建过程3部曲
1.申请内存，赋默认值
2.特殊调用，默认构造方法
3.建立关联


### 对象的内存布局-hotspot
markword 8字节
classpointer 4字节 此对象是哪个类  
成员变类m  int 4字节
8字节对齐

``` java
    public class ObjectLayOut {
    
    static class MyObject{
        int m = 1;
    }

    public static void main(String[] args) {
        Object o = new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());

        MyObject o1 = new MyObject();

        System.out.println(ClassLayout.parseInstance(o1).toPrintable());
    }
}
```
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

**12字节 + 4字节(字节对齐)**

cn.ObjectLayOut$MyObject object internals:
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
8     4        (object header)                           d0 cb 00 f8 (11010000 11001011 00000000 11111000) (-134165552)
12     4    int MyObject.m                                1
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total

**16字节 + 0字节(字节对齐)**

``` java
    public class ObjectLayOut {
    
    static class MyObject{
        int m = 1;
    }

    public static void main(String[] args) {
        Object o = new Object();
        System.out.println(ClassLayout.parseInstance(o).toPrintable());

        MyObject o1 = new MyObject();

        System.out.println(ClassLayout.parseInstance(o1).toPrintable());
    }
}
```

java.lang.Object object internals:
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0     4        (object header)                           50 f8 ec 02 (01010000 11111000 11101100 00000010) (49084496)
4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
8     4        (object header)                           e5 01 00 f8 (11100101 00000001 00000000 11111000) (-134217243)
12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

cn.ObjectLayOut$MyObject object internals:
OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
0     4        (object header)                           05 b0 ed 02 (00000101 10110000 11101101 00000010) (49131525)
4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
8     4        (object header)                           d0 cb 00 f8 (11010000 11001011 00000000 11111000) (-134165552)
12     4    int MyObject.m                                1
Instance size: 16 bytes
Space losses: 0 bytes internal + 0 bytes external = 0 bytes total

![JMM](https://isblog.oss-cn-guangzhou.aliyuncs.com/JVM/javaObjectMemoryInfo.jpg)



what's the different ?
**markword**



### 指针压缩


jdk1.6后 默认开启所有指针，对象头，成员变量

-XX:+UseCompressedOops

-XX:-UseCompressedOops


只压缩对象头里的类型指针 Klass Pointer

-XX:+UseCompressedClassPointers

-XX:-UseCompressedClassPointers


### 对象内存分配


![对象内存分配](/medias/Java/JVM/1657251117316.png)


对象逃逸？

方法内的对象被外部引用

``` java
  
    public User getUser() {
        User user = new User();
        user.setId(1);
        user.setName("zhangsan");
        return user;
    }
}
```

如果逃逸分析得出该对象不存在逃逸且对象占用内存较小，直接在变量替换。

把对象的成员变量进行拆解。


开启逃逸分析，默认开启。

-XX:+DoEscapeAnalysis 

-XX:-DoEscapeAnalysis


开启标量替换，JDK1.7之后默认开启

-XX:+EliminateAllocations

-XX:-EliminateAllocations

### 无用的类

1. 该类所有的对象实例已经被回收，java堆中不存在该类的任何实例

2.加载该类的 ClassLoader 已经被回收

3.该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法

