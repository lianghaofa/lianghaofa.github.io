---
title: 并发编程
summary: 并发编程三大特性
categories: 并发编程
date: 2021-09-07 09:25:00
tags:
- 并发
---
## 并发编程三大特性 ： 可见性，有序性，原子性

### 可见性
volatile  缓存与主存    volatile  缓存与内存保持一致性

``` java
     private static boolean running = true; this can't stop.
    //private static volatile boolean running = true;  this can stop.
    
    
    private static void m(){
        System.out.println("m start");
        while (running){

        }
        System.out.println("m end");
    }

    public static void main(String[] args) {
        new Thread(HelloVolatile::m, "t1").start();

        running = false;
    }
    
    // 修改对象时，只对引用对象的可见性，不对对象的内置值起效。
    
    A a1 = new A();
    
    volatile A a = new A();
    
    // it work.
    a = a1;
    
    // it does't work.
    a.val = 1;
```
### 有序性

提高效率，破坏有序性。
如何在保证程序的正常运行。
不影响最终的结果。

```java
    private static volatile boolean ready = false;
    private static int number;
    private static class ReaderThread extends Thread{
        @Override
        public void run() {

            // loop
            while (!ready){
                //
                Thread.yield();
            }
            // when ready = true, sout
            System.out.println(number);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread t = new ReaderThread();
        t.start();
        number = 42;
        // ready = true 不能保证 loop的马上停止。  private static volatile boolean ready = false;  volatile 可保证可见性
        // number = 42 可能比 ready = true 更早执行
        ready = true;
        t.join();
    }
```

``` java
    // source code
    class T {
        int m = 8;
    }

    T t = new T();

    // after compile
    0 new #2 <T>     // 申请内存  赋默认值 m = 0
    3 dup
    4 invokespecial #3 <T.<init>>   // 特殊调用  默认构造方法  m = 8
    7 astore_1      // 建立关联   t 指向 此对象
    8 return
    
    可能乱序  先7后4
    4 invokespecial #3 <T.<init>>   // 特殊调用  默认构造方法  m = 8
    7 astore_1      // 建立关联   t 指向 此对象
    当执行7后，有线程调用t.m 此时结果为 0 
    
    
    
    private int num= 8;
    Thread t;
    
    // 不要在构造方法内启动线程
    NoVisibility(){
        t = new Thread(()-> System.out.println(this.num));
        t.start();
    }
    // create a start method
    NoVisibility(){
        t = new Thread(()-> System.out.println(this.num));
    }
    
    public void start(){
        t.start();
    }
    
    NoVisibility(){
        t = new Thread(()-> System.out.println(this.num));
        t.start();
    }
    

    public static void main(String[] args) throws InterruptedException {
        
        new NoVisibility();
        
        System.out.println();
    }
    
```
### 原子性
```java
    private static long n = 0L;

    public static void main(String[] args) throws InterruptedException {
        Thread[] threads = new Thread[100];
        CountDownLatch latch = new CountDownLatch(threads.length);
        //  100 个线程，每个线程执行 10000次 N ++ . 100 * 10000 = 1000000 ?  not sure!
        for (int i = 0; i < threads.length; i ++){
            threads[i]= new Thread(()->{
               for (int j = 0; j < 10000; j ++){
                   n ++;
               }
               latch.countDown();
            });
        }
        // 启动100个线程
        for (Thread t : threads){
            t.start();
        }
        latch.await();
        // 不一定 1000000
        System.out.println(n);
    }
```
如何保证原子性？
```java
    for (int j = 0; j < 10000; j ++){
        synchronized (NoVisibility.class){
            n ++;
        }
    }
```
上锁 synchronized
synchronized 保证可见性与原子性，操作完内存与缓存保持一致
上锁的本质：并发编程的序列化

### 如何保证原子性操作

悲观锁

乐观锁--乐观地认为不会被其他线程打断，CAS
compare and swap
compare and exchange
1.直接读取数据

2.回写数据时，先检查当前数据是否与起始值一致

不一致，回到第一步，循环执行。
![CAS](https://isblog.oss-cn-guangzhou.aliyuncs.com/632982-20200802111508441-66209987.png)
```java
    // 最终直接调用CPU的CAS指令
    // CPU的CAS指令也不是原子性，所以lock CAS
    AtomicInteger atomicInteger = new AtomicInteger();
```

两种锁的效率：
悲观锁，一般在队列等待，不占用CPU。
应用场景：等待的线程多，占用时间长。
乐观锁，自旋等待，消耗CPU。
应用场景：线程执行时间短，因此自旋等待的次数不多，消耗CPU资源少。

**synchronized 进行了各种优化，内置悲观锁与乐观锁，实战一般推荐synchronized**

