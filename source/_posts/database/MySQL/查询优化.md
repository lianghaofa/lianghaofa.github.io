---
title: MySQL 查询优化
date: 2022-05-14 19:45:52
summary: MySQL 查询优化
categories: 数据库
tags:
- MySQL
---
## 查询优化

### 查询慢的原因

- 网络
- CPU
- IO
- 上下文切换
- 系统调用
- 生成统计信息
- 锁等待时间


### 优化查询访问


减少IO次数

![查看bin相关参数](/medias/MySQL/1652580134.png)

文件排序与索引排序

rows = 1, rows = 16005. 查询的数据非常大，不会使用索引排序？

select * from rental limit 10000,5;
![查看bin相关参数](/medias/MySQL/1652581662.png)

10000，过大会全盘扫描，如何优化？

子查询



查询不必要的记录
需要多少条就返回多少表，limit


不要使用 * ，不要取出所有列

重复查询相同的数据，查询缓存。高版本MySQL没有缓存，使用redis。

查看执行成本

show status like 'last_query_cost'



### 执行过程的优化

分析，优化，执行

语法解析器

查询优化器


A join B join C, join 的顺序不确定。

MySQL不考虑其他并发执行的查询。

#### 优化器的优化策略

静态优化 - 直接对解析进行分析，然后完成优化  

动态优化 - 动态优化与查询的上下文有关，与表的行数等有关

MySQL对查询的静态优化只需要一次，但对动态优化在每次执行时需要重新评估。

#### 优化器的优化类型

- 重新定义关联的顺序
  A join B join C, join 的顺序不确定，优化器进行了优化。

straight_join 明确读取顺序

![查看bin相关参数](/medias/MySQL/42d59448d90471f4507e849b3a12c9a.png)



- 内连接效率高于外连接 内连接获取的数据量少于外连接

- 使用等价变化规则  a!= 4 , a > 4 and a < 4  能使用单句尽量单句

- 优化 count(),min(),max() 

- 子查询优化

- 等值传播 

- 排序的算法

order by 的排序算法

两次传输排序 - 先读取需要排序的字段，然后再读取整体结果

让内存容纳更多的记录
 
单词传输排序

先读取需要排序的所有列，内存中排序。

当需要排序的总大小加上orderby的列大小超过max_length_for_sort_data定义的字节，mysql会选择两次排序，反之使用单词排序。
用户可以设置max_length_for_sort_data 参数的值来选择排序的方式。


### 优化特定类型的查询


#### 优化count查询
select count(*) from rental;

select count(rental_id) from rental;

select count(1) from rental;

![查看执行代价](/medias/MySQL/1652662453.png)

![查看执行时间](/medias/MySQL/1652662549.png)

![查看执行时间](/medias/MySQL/1652662603.png)

![查看执行时间](/medias/MySQL/1652662652.png)

MyiSam 的count函数比较快，因为记录了总体的行数。但加上where条件，就没有优势了

#### 优化关联查询

创建索引时要考虑关联的顺序


确保任何的groupby,orderby中的表达式只涉及一个表中的列，这样mysql才有可能使用索引优化

#### 优化子查询

子查询会生成临时表，尽可能使用关联查询

可以理解成，临时表与结果表。

关联插叙直接放到结果表。

#### 优化limit分页

尽可能使用覆盖索引，而不是查询所有的列



#### 优化union查询

| name      | subject | score |
| :----: | :----: |:----: |
| zs      | Chinese   |89 |
| zs   | Math    | 89 |
| zs     | English   | 89 |
| ls      | Chinese   |89 |
| ls   | Math    | 89 |
| ls     | English   | 89 |

行转列

name  Chinese  Math  English

MySQL

join , union, case when

除非明确需要服务器消除重复的行，否则一定要使用union all,因为没有all关键字，mysql会在查询的时候给临时表加上distinct关键字，这个操作的代价很高。

#### 自定义变量
set @one := 1;

select @one;

##### 限制：
- 无法使用查询缓存

- 不能在使用常量或者标标识符的地方使用自定义变量，例如表名，列名或limit子句

- 用户自定义变量的生命周期实在一个连接内有效，不能用作连接间的通信

- 不能显示地声明自定义变量的类型

- mysql优化器在某些场景下可能会把这些变量优化掉，这可能导致代码不按预想的方式运行

- 赋值符号：= 的优先级非常低，所以在使用赋值表达式的时候应明确使用括号

- 使用未定义变量不会产生任何语法错误

##### 使用案例

- 优化排名查询
select actor_id,@rownum := @rownum + 1 as rownum from actor limit 10;

![未定义变量，默认NULL](/medias/MySQL/1652662652.png)

![优化排名查询](/medias/MySQL/1652669711.png)


- 避免查询刚刚更新的数据

- 













